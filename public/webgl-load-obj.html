<p>Title: WebGL2 Load Obj<br />Description: How to parse and display an .OBJ file<br />TOC: Loading .obj files</p>

<p>Wavefront .obj files are one of the most common formats of<br />3D files you can find online. They are not that hard to<br />parse the most common forms so let's parse one. It will<br />hopefully provide a useful example for parsing 3D formats<br />in general.</p>

<p><strong>Disclaimer:</strong> This .OBJ parser is not meant to be exhaustive or<br />flawless or handle every .OBJ file. Rather it's meant as an<br />exercise to walk through handling what we run into on the way.<br />That said, if you run into big issues and solutions a comment<br />at the bottom might be helpful for others if they choose to<br />use this code.</p>

<p>The best documentation I've found for the .OBJ format is<br /><a href="http://paulbourke.net/dataformats/obj/">here</a>. Though <br /><a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000507.shtml">this page</a><br />links to many other documents including what appears to<br /><a href="http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf">the original docs</a>.</p>

<p>Let's look a simple example. Here is a cube.obj file exported from blender's default scene.</p>

<pre><code>
# Blender v2.80 (sub 75) OBJ File: ''
# www.blender.org
mtllib cube.mtl
o Cube
v 1.000000 1.000000 -1.000000
v 1.000000 -1.000000 -1.000000
v 1.000000 1.000000 1.000000
v 1.000000 -1.000000 1.000000
v -1.000000 1.000000 -1.000000
v -1.000000 -1.000000 -1.000000
v -1.000000 1.000000 1.000000
v -1.000000 -1.000000 1.000000
vt 0.375000 0.000000
vt 0.625000 0.000000
vt 0.625000 0.250000
vt 0.375000 0.250000
vt 0.375000 0.250000
vt 0.625000 0.250000
vt 0.625000 0.500000
vt 0.375000 0.500000
vt 0.625000 0.750000
vt 0.375000 0.750000
vt 0.625000 0.750000
vt 0.625000 1.000000
vt 0.375000 1.000000
vt 0.125000 0.500000
vt 0.375000 0.500000
vt 0.375000 0.750000
vt 0.125000 0.750000
vt 0.625000 0.500000
vt 0.875000 0.500000
vt 0.875000 0.750000
vn 0.0000 1.0000 0.0000
vn 0.0000 0.0000 1.0000
vn -1.0000 0.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 0.0000 -1.0000
usemtl Material
s off
f 1/1/1 5/2/1 7/3/1 3/4/1
f 4/5/2 3/6/2 7/7/2 8/8/2
f 8/8/3 7/7/3 5/9/3 6/10/3
f 6/10/4 2/11/4 4/12/4 8/13/4
f 2/14/5 1/15/5 3/16/5 4/17/5
f 6/18/6 5/19/6 1/20/6 2/11/6
</code></pre>

<p>Without even looking at the documentation we can probably figure<br />out that lines that start with <code>v</code> are positions, lines that<br />start with<code>vt</code> are texture coordinates, and lines that start<br />with <code>vn</code> are normals. What's left is to figure out the rest.</p>

<p>It appears .OBJ files are text files so the first thing we need<br />to do is load a text file. Fortunately in 2020 that's super easy<br />if we use <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await">async/await</a>.</p>

<pre><code>
async function main() {
  ...

  const response = await fetch('resources/models/cube/cube.obj');
  const text = await response.text();
</code></pre>

<p>Next it looks like we can parse it one line at time and that<br />each line is in the form of</p>

<div class="highlight"><pre lang="">keyword data data data data ...
</pre></div>

<p>where the first thing on the line is a keyword and data<br />is separated by spaces. Lines that start with <code>#</code> are comments.</p>

<p>So, let's set up some code to parse each line, skip blank lines<br />and comments and then call some function based on the keyword</p>

<pre><code>
+function parseOBJ(text) {
+
+  const keywords = {
+  };
+
+  const keywordRE = /(\w*)(?: )*(.*)/;
+  const lines = text.split('\n');
+  for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
+    const line = lines[lineNo].trim();
+    if (line === '' || line.startsWith('#')) {
+      continue;
+    }
+    const parts = line.split(/\s+/);
+    const m = keywordRE.exec(line);
+    if (!m) {
+      continue;
+    }
+    const [, keyword, unparsedArgs] = m;
+    const parts = line.split(/\s+/).slice(1);
+    const handler = keywords[keyword];
+    if (!handler) {
+      console.warn('unhandled keyword:', keyword, 'at line', lineNo + 1);
+      continue;
+    }
+    handler(parts, unparsedArgs);
+  }
}
</code></pre>

<p>Some things to note: We trim each line to remove leading and trailing<br />spaces. I have no idea if this is needed but I think it can't hurt.<br />We split the line by white space using <code>/\s+/</code>. Again I have no idea if<br />this is needed. Can there be more than one space between data? Can<br />there be tabs? No idea but it seemed safer to assume there is variation<br />out there given it's a text format.</p>

<p>Otherwise we pull out the first part as the keyword and then look up a function<br />for that keyword and call it passing it the data after the keyword. So now we<br />just need to fill in those functions.</p>

<p>We guessed the <code>v</code>, <code>vt</code>, and <code>vn</code> data above. The docs say <code>f</code><br />stands for "face" or polygon where each piece of data are<br />indices into the positions, texture coordinates, and normals.</p>

<p>The indices are 1 based if positive or relative to the number<br />of vertices parsed so far if negative.<br />The order of the indices are position/texcoord/normal and<br />that all except the position are optional so</p>

<pre><code>
f 1 2 3              # indices for positions only
f 1/1 2/2 3/3        # indices for positions and texcoords
f 1/1/1 2/2/2 3/3/3  # indices for positions, texcoords, and normals
f 1//1 2//2 3//3     # indices for positions and normals
</code></pre>

<p><code>f</code> can have more than 3 vertices, for example 4 for a quad<br />We know that WebGL can only draw triangles so we need to convert<br />the data to triangles. It does not say if a face can have more<br />than 4 vertices nor does it says if the face must be convex or<br />if it can be concave. For now lets assume they are concave.</p>

<p>Also, in general, in WebGL we don't use a different index for<br />positions, texcoords, and normals. Instead a "webgl vertex"<br />is the combination of all data for that vertex. So for example<br />to draw a cube WebGL requires 36 vertices, each face is 2 triangles,<br />each triangle is 3 vertices. 6 faces * 2 triangles * 3 vertices<br />per triangle is 36. Even though there are only 8 unique positions,<br />6 unique normals, and who knows for texture coordinates. So, we'll<br />need to read the face vertex indices and generate a "webgl vertex"<br />that is the combination of data of all 3 things. <a href="webgl-pulling-vertices.html">*</a></p>

<p>So given all that it looks like we can parse these parts as follows</p>

<pre><code>
function parseOBJ(text) {
+  // because indices are base 1 let's just fill in the 0th data
+  const objPositions = [[0, 0, 0]];
+  const objTexcoords = [[0, 0]];
+  const objNormals = [[0, 0, 0]];
+
+  // same order as `f` indices
+  const objVertexData = [
+    objPositions,
+    objTexcoords,
+    objNormals,
+  ];
+
+  // same order as `f` indices
+  let webglVertexData = [
+    [],   // positions
+    [],   // texcoords
+    [],   // normals
+  ];
+
+  function addVertex(vert) {
+    const ptn = vert.split('/');
+    ptn.forEach((objIndexStr, i) => {
+      if (!objIndexStr) {
+        return;
+      }
+      const objIndex = parseInt(objIndexStr);
+      const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
+      webglVertexData[i].push(...objVertexData[i][index]);
+    });
+  }
+
  const keywords = {
+    v(parts) {
+      objPositions.push(parts.map(parseFloat));
+    },
+    vn(parts) {
+      objNormals.push(parts.map(parseFloat));
+    },
+    vt(parts) {
+      objTexcoords.push(parts.map(parseFloat));
+    },
+    f(parts) {
+      const numTriangles = parts.length - 2;
+      for (let tri = 0; tri < numTriangles; ++tri) {
+        addVertex(parts[0]);
+        addVertex(parts[tri + 1]);
+        addVertex(parts[tri + 2]);
+      }
+    },
  };
</code></pre>

<p>The code above creates 3 arrays to hold the positions, texcoords, and<br />normals parsed from the object file. It also creates 3 arrays to hold<br />the same for WebGL. These are put in arrays as well in the same order<br />as the <code>f</code> indices to make it easy to reference when we parse <code>f</code>.</p>

<p>In other words an <code>f</code> line like</p>

<pre><code>
f 1/2/3 4/5/6 7/8/9
</code></pre>

<p>One of those parts <code>4/5/6</code> is saying "use position 4" for this face vertex, "use<br />texcoord 5" and "use normal 6" but by putting the position, texcoord, and normal<br />arrays themselves in an array, the <code>objVertexData</code> array, we can simplify that to<br />"use item n of objData i for webglData i" which lets us make the code simpler.</p>

<p>At end of our function we return the data we've built up</p>

<pre><code>
  ...

  return {
    position: webglVertexData[0],
    texcoord: webglVertexData[1],
    normal: webglVertexData[2],
  };
}
</code></pre>

<p>All that's left to do is draw the data. First we'll use a variation<br />of the shaders from <a href="webgl-3d-lighting-directional.html">the article on directional lighting</a>.</p>

<pre><code>
const vs = `#version 300 es
  in vec4 a_position;
  in vec3 a_normal;

  uniform mat4 u_projection;
  uniform mat4 u_view;
  uniform mat4 u_world;

  out vec3 v_normal;

  void main() {
    gl_Position = u_projection * u_view * u_world * a_position;
    v_normal = mat3(u_world) * a_normal;
  }
`;

const fs = `#version 300 es
  precision highp float;

  in vec3 v_normal;

  uniform vec4 u_diffuse;
  uniform vec3 u_lightDirection;

  out vec4 outColor;

  void main () {
    vec3 normal = normalize(v_normal);
    float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
    outColor = vec4(u_diffuse.rgb * fakeLight, u_diffuse.a);
  }
`;
</code></pre>

<p>Then, using the code from the article on <br /><a href="webgl-less-code-more-fun.html">less code more fun</a><br />first we'll load our data</p>

<pre><code>
async function main() {
  // Get A WebGL context
  /** @type {HTMLCanvasElement} */
  const canvas = document.querySelector("#canvas");
  const gl = canvas.getContext("webgl2");
  if (!gl) {
    return;
  }

  // Tell the twgl to match position with a_position etc..
  twgl.setAttributePrefix("a_");

  ... shaders ...

  // compiles and links the shaders, looks up attribute and uniform locations
  const meshProgramInfo = twgl.createProgramInfo(gl, [vs, fs]);

  const response = await fetch('resources/models/cube/cube.obj');
  const text = await response.text();
  const data = parseOBJ(text);

  // Because data is just named arrays like this
  //
  // {
  //   position: [...],
  //   texcoord: [...],
  //   normal: [...],
  // }
  //
  // and because those names match the attributes in our vertex
  // shader we can pass it directly into `createBufferInfoFromArrays`
  // from the article "less code more fun".

  // create a buffer for each array by calling
  // gl.createBuffer, gl.bindBuffer, gl.bufferData
  const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
  // fills out a vertex array by calling gl.createVertexArray, gl.bindVertexArray
  // then gl.bindBuffer, gl.enableVertexAttribArray, and gl.vertexAttribPointer for each attribute
  const vao = twgl.createVAOFromBufferInfo(gl, meshProgramInfo, bufferInfo);
</code></pre>

<p>and then we'll draw it</p>

<pre><code>
  const cameraTarget = [0, 0, 0];
  const cameraPosition = [0, 0, 4];
  const zNear = 0.1;
  const zFar = 50;

  function degToRad(deg) {
    return deg * Math.PI / 180;
  }

  function render(time) {
    time *= 0.001;  // convert to seconds

    twgl.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);

    const fieldOfViewRadians = degToRad(60);
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
    const projection = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

    const up = [0, 1, 0];
    // Compute the camera's matrix using look at.
    const camera = m4.lookAt(cameraPosition, cameraTarget, up);

    // Make a view matrix from the camera matrix.
    const view = m4.inverse(camera);

    const sharedUniforms = {
      u_lightDirection: m4.normalize([-1, 3, 5]),
      u_view: view,
      u_projection: projection,
    };

    gl.useProgram(meshProgramInfo.program);

    // calls gl.uniform
    twgl.setUniforms(meshProgramInfo, sharedUniforms);

    // set the attributes for this part.
    gl.bindVertexArray(vao);

    // calls gl.uniform
    twgl.setUniforms(meshProgramInfo, {
      u_world: m4.yRotation(time),
      u_diffuse: [1, 0.7, 0.5, 1],
    });

    // calls gl.drawArrays or gl.drawElements
    twgl.drawBufferInfo(gl, bufferInfo);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
}
</code></pre>

<p>And with that we can see our cube is loaded and drawing</p>

<p>{{{example url="../webgl-load-obj-cube.html"}}}</p>

<p>We also see some messages about unhandled keywords. What are those for?</p>

<p><code>usemat</code> is the most important of these. It specifies that all geometry that<br />appears after uses a specific material. For example if you had a model of a car<br />you probably want transparent windows and chrome bumpers. The windows are<br /><a href="webgl-text-texture.html">transparent</a> and the bumpers are<br /><a href="webgl-environment-maps.html">reflective</a> so they need to be drawn differently<br />than the body of the car. The <code>usemat</code> tag marks this separation of parts.</p>

<p>Because we'll need to draw each of these parts separately let's fix<br />the code so that each time we see a <code>usemat</code> we'll start a new set of webgl<br />data.</p>

<p>First let's make some code that starts a new webgl data if we don't already<br />have some</p>

<pre><code>
function parseOBJ(text) {
  // because indices are base 1 let's just fill in the 0th data
  const objPositions = [[0, 0, 0]];
  const objTexcoords = [[0, 0]];
  const objNormals = [[0, 0, 0]];

  // same order as `f` indices
  const objVertexData = [
    objPositions,
    objTexcoords,
    objNormals,
  ];

  // same order as `f` indices
  let webglVertexData = [
    [],   // positions
    [],   // texcoords
    [],   // normals
  ];

+  const geometries = [];
+  let geometry;
+  let material = 'default';
+
+  function newGeometry() {
+    // If there is an existing geometry and it's
+    // not empty then start a new one.
+    if (geometry && geometry.data.position.length) {
+      geometry = undefined;
+    }
+  }
+
+  function setGeometry() {
+    if (!geometry) {
+      const position = [];
+      const texcoord = [];
+      const normal = [];
+      webglVertexData = [
+        position,
+        texcoord,
+        normal,
+      ];
+      geometry = {
+        material,
+        data: {
+          position,
+          texcoord,
+          normal,
+        },
+      };
+      geometries.push(geometry);
+    }
+  }

...
</code></pre>

<p>and then let's call those in the correct places when<br />handling our keywords including adding the <code>o</code> keyword<br />function.</p>

<pre><code>
  ...

  const keywords = {
    v(parts) {
      objPositions.push(parts.map(parseFloat));
    },
    vn(parts) {
      objNormals.push(parts.map(parseFloat));
    },
    vt(parts) {
      objTexcoords.push(parts.map(parseFloat));
    },
    f(parts) {
+      setGeometry();
      const numTriangles = parts.length - 2;
      for (let tri = 0; tri < numTriangles; ++tri) {
        addVertex(parts[0]);
        addVertex(parts[tri + 1]);
        addVertex(parts[tri + 2]);
      }
    },
+    usemtl(parts, unparsedArgs) {
+      material = unparsedArgs;
+      newGeometry();
+    },
  };

  ...

</code></pre>

<p>The <code>usemtl</code> keyword is not required so if there is no <code>usemtl</code> in the file<br />we still want geometry so in the <code>f</code> handler we call <code>setGeometry</code><br />which will start some if there was no <code>usemtl</code> keyword in the file before<br />that point.</p>

<p>Otherwise at the end we'll return <code>geometries</code> which<br />is an array of objects, each of which contain <code>name</code> and <code>data</code>.</p>

<pre><code>
  ...

-  return {
-    position: webglVertexData[0],
-    texcoord: webglVertexData[1],
-    normal: webglVertexData[2],
-  };
+  return geometries;
}
</code></pre>

<p>While we're here we should also handle the case where texcoords<br />or normals are missing and just not include them.</p>

<pre><code>
+  // remove any arrays that have no entries.
+  for (const geometry of geometries) {
+    geometry.data = Object.fromEntries(
+        Object.entries(geometry.data).filter(([, array]) => array.length > 0));
+  }

  return {
    materialLibs,
    geometries,
  };
}
</code></pre>

<p>Continuing with keywords, According to the <a href="http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf"><em>official spec</em></a>,<br /><code>matlib</code> specifies separate file(s) that contains material info. Unfortunately that<br />doesn't seem to match reality because filenames can have spaces them and the .OBJ format<br />provides no way to escape spaces or quote arguments. Ideally they should have used a well defined format<br />like json or xml or yaml or something that solves this issue but in their defense .OBJ is older<br />than any of those formats.</p>

<p>We handle loading the file latter.<br />For now let's just add it on to our loader so we can reference it later.</p>

<pre><code>
function parseOBJ(text) {
  ...
+  const materialLibs = [];

  ...

  const keywords = {
    ...
+    mtllib(parts, unparsedArgs) {
+      materialLibs.push(unparsedArgs);
+    },
    ...
  };

-  return geometries;
+  return {
+    materialLibs,
+    geometries,
+  };
}
</code></pre>

<p><code>o</code> specifies the following items belong to the named "object". It's<br />not really clear how to use this. Can we have a file with just <code>o</code><br />but no <code>usemat</code>? Let's assume yes.</p>

<pre><code>
function parseOBJ(text) {
  ...
  let material = 'default';
+  let object = 'default';

  ...

  function setGeometry() {
    if (!geometry) {
      const position = [];
      const texcoord = [];
      const normal = [];
      webglVertexData = [
        position,
        texcoord,
        normal,
      ];
      geometry = {
+        object,
        material,
        data: {
          position,
          texcoord,
          normal,
        },
      };
      geometries.push(geometry);
    }
  }

  const keywords = {
    ...
+    o(parts, unparsedArgs) {
+      object = unparsedArgs;
+      newGeometry();
+    },
    ...
  };
</code></pre>

<p><code>s</code> specifies a smoothing group. I think smoothing groups is<br />mostly something we can ignore. Usually they are used in a modeling<br />program to auto generate vertex normals. A vertex normal is computed<br />first computing the normal of each face which is easy using the <em>cross product</em><br />which we covered in <a href="webgl-3d-camera.html">the article on cameras</a>.<br />Then, for any vertex we can average all the faces it shares. But, if we<br />want a hard edge sometimes we need to be able to tell the system to<br />ignore a face. Smoothing groups let you designate which faces will get<br />included when computing vertex normals. As for computing vertex normals<br />for geometry in general you can look in <a href="webgl-3d-geometry-lathe.html">the article on lathing</a> for one example.</p>

<p>For our case let's just ignore them. It suspect most .obj files have<br />normals internally and so probably don't need smoothing groups. They keep<br />them around for modeling packages incase you want to edit and regenerate<br />normals.</p>

<pre><code>
+  const noop = () => {};

  const keywords = {
    ...
+    s: noop,
    ...
  };
</code></pre>

<p>One more keyword we haven't seen yet is <code>g</code> for group. It's basically<br />just meta data. Objects can belong to more than one group.<br />Because it will appear in the next file we try let's add support here<br />even though we won't actually use the data.</p>

<pre><code>
function parseOBJ(text) {
  ...
+  let groups = ['default'];
  ...
  function setGeometry() {
    if (!geometry) {
      const position = [];
      const texcoord = [];
      const normal = [];
      webglVertexData = [
        position,
        texcoord,
        normal,
      ];
      geometry = {
        object,
+        groups,
        material,
        data: {
          position,
          texcoord,
          normal,
        },
      };
      geometries.push(geometry);
    }
  }

  ...

  const keywords = {
    ...
+    g(parts) {
+      groups = parts;
+      newGeometry()
+    },
    ...
  };
</code></pre>

<p>Now that we're creating multiple sets of geometry we need to change<br />our setup code to create <code>WebGLBuffers</code> for each one. We'll also create<br />a random color so hopefully it's easy to see the different parts.</p>

<pre><code>
-  const response = await fetch('resources/models/cube/cube.obj');
+  const response = await fetch('resources/models/cube/chair.obj');
  const text = await response.text();
-  const data = parseOBJ(text);
+  const obj = parseOBJ(text);

+  const parts = obj.geometries.map(({data}) => {
    // Because data is just named arrays like this
    //
    // {
    //   position: [...],
    //   texcoord: [...],
    //   normal: [...],
    // }
    //
    // and because those names match the attributes in our vertex
    // shader we can pass it directly into `createBufferInfoFromArrays`
    // from the article "less code more fun".

    // create a buffer for each array by calling
    // gl.createBuffer, gl.bindBuffer, gl.bufferData
    const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
    // fills out a vertex array by calling gl.createVertexArray, gl.bindVertexArray
    // then gl.bindBuffer, gl.enableVertexAttribArray, and gl.vertexAttribPointer for each attribute
    const vao = twgl.createVAOFromBufferInfo(gl, meshProgramInfo, bufferInfo);
+    return {
+      material: {
+        u_diffuse: [Math.random(), Math.random(), Math.random(), 1],
+      },
+      bufferInfo,
+      vao,
+    };
+  });
</code></pre>

<p>I switched from loading a cube to loading this <a href="http://creativecommons.org/licenses/by/4.0/">CC-BY 4.0</a> <a href="https://sketchfab.com/3d-models/chair-aa2acddb218646a59ece132bf95aa558">chair</a> by <a href="https://sketchfab.com/haytonm">haytonm</a> I found on <a href="https://sketchfab.com/">Sketchfab</a></p>

<div class="webgl_center"><img src="../resources/models/chair/chair.jpg" style="width: 452px;"></div>

<p>To render we just need to loop over the parts</p>

<pre><code>
function render(time) {
  ...

  gl.useProgram(meshProgramInfo.program);

  // calls gl.uniform
  twgl.setUniforms(meshProgramInfo, sharedUniforms);

+  // compute the world matrix once since all parts
+  // are at the same space.
+  const u_world = m4.yRotation(time);
+
+  for (const {bufferInfo, vao material} of parts) {
    // set the attributes for this part.
    gl.bindVertexArray(vao);
    // calls gl.uniform
    twgl.setUniforms(meshProgramInfo, {
-      u_world: m4.yRotation(time),
-      u_diffuse: [1, 0.7, 0.5, 1],
+      u_world,
+      u_diffuse: material.u_diffuse,
    });
    // calls gl.drawArrays or gl.drawElements
    twgl.drawBufferInfo(gl, bufferInfo);
+  }

  ...
</code></pre>

<p>and that kinda works</p>

<p>{{{example url="../webgl-load-obj.html"}}}</p>

<p>Wouldn't it be nice if we could try to center the object?</p>

<p>To do that we need to compute the extents which is the minimum<br />and maximum vertex positions. So first we can make a function<br />that given positions will figure out the min and max positions</p>

<pre><code>
function getExtents(positions) {
  const min = positions.slice(0, 3);
  const max = positions.slice(0, 3);
  for (let i = 3; i < positions.length; i += 3) {
    for (let j = 0; j < 3; ++j) {
      const v = positions[i + j];
      min[j] = Math.min(v, min[j]);
      max[j] = Math.max(v, max[j]);
    }
  }
  return {min, max};
}
</code></pre>

<p>and then we can loop over all the parts of our geometry and<br />get the extents for all parts</p>

<pre><code>
function getGeometriesExtents(geometries) {
  return geometries.reduce(({min, max}, {data}) => {
    const minMax = getExtents(data.position);
    return {
      min: min.map((min, ndx) => Math.min(minMax.min[ndx], min)),
      max: max.map((max, ndx) => Math.max(minMax.max[ndx], max)),
    };
  }, {
    min: Array(3).fill(Number.POSITIVE_INFINITY),
    max: Array(3).fill(Number.NEGATIVE_INFINITY),
  });
}
</code></pre>

<p>Then we can use that to compute how far to translate the object<br />so its center is at the origin and a distance from the origin<br />to place the camera so hopefully we can see all of it.</p>

<pre><code>
-  const cameraTarget = [0, 0, 0];
-  const cameraPosition = [0, 0, 4];
-  const zNear = 0.1;
-  const zFar = 50;
+  const extents = getGeometriesExtents(obj.geometries);
+  const range = m4.subtractVectors(extents.max, extents.min);
+  // amount to move the object so its center is at the origin
+  const objOffset = m4.scaleVector(
+      m4.addVectors(
+        extents.min,
+        m4.scaleVector(range, 0.5)),
+      -1);
+  const cameraTarget = [0, 0, 0];
+  // figure out how far away to move the camera so we can likely
+  // see the object.
+  const radius = m4.length(range) * 1.2;
+  const cameraPosition = m4.addVectors(cameraTarget, [
+    0,
+    0,
+    radius,
+  ]);
+  // Set zNear and zFar to something hopefully appropriate
+  // for the size of this object.
+  const zNear = radius / 100;
+  const zFar = radius * 3;
</code></pre>

<p>Above we also set <code>zNear</code> and <code>zFar</code> to something that hopefully shows the object<br />well.</p>

<p>We just need to use the <code>objOffset</code> to translate the object to the origin</p>

<pre><code>
// compute the world matrix once since all parts
// are at the same space.
-const u_world = m4.yRotation(time);
+let u_world = m4.yRotation(time);
+u_world = m4.translate(u_world, ...objOffset);
</code></pre>

<p>and with that the object is centered.</p>

<p>{{{example url="../webgl-load-obj-w-extents.html"}}}</p>

<p>Looking around the net it turns out there are non-standard versions of<br />.OBJ files that include vertex colors. To do this they tack on extra<br />values to each vertex position so instead of</p>

<div class="highlight"><pre lang="">v <x> <y> <z>

<pre><code>
</code></pre>

v <x> <y> <z> <red> <green> <blue>
</pre></div>

<p>It's not clear if there is also an optional alpha at end of that.</p>

<p>I looked around and found this <a href="https://sketchfab.com/3d-models/book-vertex-chameleon-study-51b0b3bdcd844a9e951a9ede6f192da8">Book - Vertex chameleon study</a> by <a href="https://sketchfab.com/homkahom0">Oleaf</a> License: <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC</a> that uses vertex colors.</p>

<div class="webgl_center"><img src="../resources/models/book-vertex-chameleon-study/book.png" style="width: 446px;"></div>

<p>Let's see if we can add in support to our parser to handle the vertex colors.</p>

<p>We need to add stuff for colors everywhere we had position, normals, and texcoords</p>

<pre><code>
function parseOBJ(text) {
  // because indices are base 1 let's just fill in the 0th data
  const objPositions = [[0, 0, 0]];
  const objTexcoords = [[0, 0]];
  const objNormals = [[0, 0, 0]];
+  const objColors = [[0, 0, 0]];

  // same order as `f` indices
  const objVertexData = [
    objPositions,
    objTexcoords,
    objNormals,
+    objColors,
  ];

  // same order as `f` indices
  let webglVertexData = [
    [],   // positions
    [],   // texcoords
    [],   // normals
+    [],   // colors
  ];

  ...

  function setGeometry() {
    if (!geometry) {
      const position = [];
      const texcoord = [];
      const normal = [];
+      const color = [];
      webglVertexData = [
        position,
        texcoord,
        normal,
+        color,
      ];
      geometry = {
        object,
        groups,
        material,
        data: {
          position,
          texcoord,
          normal,
+          color,
        },
      };
      geometries.push(geometry);
    }
  }
</code></pre>

<p>Then unfortunately actually parsing makes the code a little less generic.</p>

<pre><code>
  const keywords = {
    v(parts) {
-      objPositions.push(parts.map(parseFloat));
+      // if there are more than 3 values here they are vertex colors
+      if (parts.length > 3) {
+        objPositions.push(parts.slice(0, 3).map(parseFloat));
+        objColors.push(parts.slice(3).map(parseFloat));
+      } else {
+        objPositions.push(parts.map(parseFloat));
+      }
    },
    ...
  };
</code></pre>

<p>Then when we read a <code>f</code> face line we call <code>addVertex</code>. We'll need to grab<br />the vertex colors here</p>

<pre><code>
  function addVertex(vert) {
    const ptn = vert.split('/');
    ptn.forEach((objIndexStr, i) => {
      if (!objIndexStr) {
        return;
      }
      const objIndex = parseInt(objIndexStr);
      const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
      webglVertexData[i].push(...objVertexData[i][index]);
+      // if this is the position index (index 0) and we parsed
+      // vertex colors then copy the vertex colors to the webgl vertex color data
+      if (i === 0 && objColors.length > 1) {
+        geometry.data.color.push(...objColors[index]);
+      }
    });
  }
</code></pre>

<p>Now we need to change our shaders to use vertex colors</p>

<pre><code>
const vs = `#version 300 es
in vec4 a_position;
in vec3 a_normal;
+in vec4 a_color;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;

out vec3 v_normal;
+out vec4 v_color;

void main() {
  gl_Position = u_projection * u_view * u_world * a_position;
  v_normal = mat3(u_world) * a_normal;
+  v_color = a_color;
}
`;

const fs = `#version 300 es
precision mediump float;

in vec3 v_normal;
+in vec4 v_color;

uniform vec4 u_diffuse;
uniform vec3 u_lightDirection;

out vec4 outColor;

void main () {
  vec3 normal = normalize(v_normal);
  float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
-  outColor = vec4(u_diffuse.rgb * fakeLight, u_diffuse.a);
+  vec4 diffuse = u_diffuse * v_color;
+  outColor = vec4(diffuse.rgb * fakeLight, diffuse.a);
}
`;
</code></pre>

<p>Like I mentioned above I have no idea if this non-standard version of .OBJ<br />can include alpha values for each vertex color. Our <a href="webgl-less-code-more-fun.html">helper library</a> has been automatically taking the data we pass it and making buffers for<br />us. It guesses how many components there are per element in the data. For data with a name<br />that contains the string <code>position</code> or <code>normal</code> it assumes 3 components per element.<br />For a name that contains <code>texcoord</code> it assumes 2 components per element. For everything<br />else it assumes 4 components per element. That means if our colors are only r, g, b,<br />3 components per element, we need to tell it so it doesn't guess 4.</p>

<pre><code>
const parts = obj.geometries.map(({data}) => {
  // Because data is just named arrays like this
  //
  // {
  //   position: [...],
  //   texcoord: [...],
  //   normal: [...],
  // }
  //
  // and because those names match the attributes in our vertex
  // shader we can pass it directly into `createBufferInfoFromArrays`
  // from the article "less code more fun".

+   if (data.position.length === data.color.length) {
+     // it's 3. The our helper library assumes 4 so we need
+     // to tell it there are only 3.
+     data.color = { numComponents: 3, data: data.color };
+   }

  // create a buffer for each array by calling
  // gl.createBuffer, gl.bindBuffer, gl.bufferData
  const bufferInfo = twgl.createBufferInfoFromArrays(gl, data);
  const vao = twgl.createVAOFromBufferInfo(gl, meshProgramInfo, bufferInfo);
  return {
    material: {
      u_diffuse: [Math.random(), Math.random(), Math.random(), 1],
    },
    bufferInfo,
    vao,
  };
});
</code></pre>

<p>We probably also want to still handle the more common case when there are no<br />vertex colors. On <a href="webgl-fundamentals.html">the first article</a> as well as<br /><a href="webgl-attributes.html">other articles</a> we covered that an attribute usually<br />gets its value from a buffer. But, we can also make attributes just be constant.<br />An attribute that is turned off uses a constant value. Example</p>

<pre><code>
gl.disableVertexAttribArray(someAttributeLocation);  // use a constant value
const value = [1, 2, 3, 4];
gl.vertexAttrib4fv(someAttributeLocation, value);    // the constant value to use
</code></pre>

<p>Our <a href="webgl-less-code-more-fun.html">helper library</a> handles this for us if<br />we set the data for that attribute to <code>{value: [1, 2, 3, 4]}</code>. So, we can<br />check if there are no vertex colors then if so set the vertex color attribute<br />to constant white.</p>

<pre><code>
const parts = obj.geometries.map(({data}) => {
  // Because data is just named arrays like this
  //
  // {
  //   position: [...],
  //   texcoord: [...],
  //   normal: [...],
  // }
  //
  // and because those names match the attributes in our vertex
  // shader we can pass it directly into `createBufferInfoFromArrays`
  // from the article "less code more fun".

+  if (data.color) {
      if (data.position.length === data.color.length) {
        // it's 3. The our helper library assumes 4 so we need
        // to tell it there are only 3.
        data.color = { numComponents: 3, data: data.color };
      }
+  } else {
+    // there are no vertex colors so just use constant white
+    data.color = { value: [1, 1, 1, 1] };
+  }

  ...
});
</code></pre>

<p>We also can't use a random color per part any more</p>

<pre><code>
const parts = obj.geometries.map(({data}) => {
  ...

  // create a buffer for each array by calling
  // gl.createBuffer, gl.bindBuffer, gl.bufferData
  const bufferInfo = twgl.createBufferInfoFromArrays(gl, data);
  const vao = twgl.createVAOFromBufferInfo(gl, meshProgramInfo, bufferInfo);
  return {
    material: {
-      u_diffuse: [Math.random(), Math.random(), Math.random(), 1],
+      u_diffuse: [1, 1, 1, 1],
    },
    bufferInfo,
    vao,
  };
});
</code></pre>

<p>And we that we're able to load an .OBJ file with vertex colors.</p>

<p>{{{example url="../webgl-load-obj-w-vertex-colors.html"}}}</p>

<p>As for parsing and using materials <a href="webgl-load-obj-w-mtl.html">see the next article</a></p>

<h2>A bunch of notes</h2>

<h3>The loader above is incomplete</h3>

<p>You can go <a href="http://paulbourke.net/dataformats/obj/">read more about the .obj format</a>.<br />The are tons of features the code above doesn't support. Also, the code has<br />not been tested on very many .obj files so maybe there are lurking bugs. That said, I <br />suspect the majority of .obj files online only use the features shown above so I suspect<br />it's probably a useful example.</p>

<h3>The loader is not checking for errors</h3>

<p>Example: the <code>vt</code> keyword can have 3 values per entry instead of just 2. 3 values<br />would be for 3D textures which is not common so I didn't bother. If you did pass it<br />a file with 3D texture coordinates you'd have to change the shaders to handle 3D<br />textures and the code that generates <code>WebGLBuffers</code> (calls <code>createBufferInfoFromArrays</code>)<br />to tell it it's 3 components per UV coordinate.</p>

<h3>It's assuming the data is homogeneous</h3>

<p>I have no idea if some <code>f</code> keywords can have 3 entries<br />and others only 2 in the same file. If that's possible the code above doesn't<br />handle it.</p>

<p>The code also assumes that if vertex positions have x, y, z they all<br />have x, y, z. If there are files out there where some vertex positions<br />have x, y, z, others have only x, y, and still others have x, y, z, r, g, b<br />then we'd have to refractor.</p>

<h3>You could put all the data in one buffer</h3>

<p>The code above puts the data for position, texcoord, normal in separate buffers.<br />You could put them in one buffer by either interleaving them <br />pos,uv,nrm,pos,uv,nrm,... but you'd then need to change<br />how the attributes are setup to pass in strides and offsets.</p>

<p>Extending that you could even put the data for all the parts in the same<br />buffers where as currently it's one buffer per data type per part.</p>

<p>I left those out because I don't think it's that important and because it would clutter the example.</p>

<h3>You could re-index the vertices</h3>

<p>The code above expands the vertices into flat lists of triangles. We could have reindexed<br />the vertices. Especially if we put all vertex data in a single buffer or at least a single<br />buffer per type but shared across parts then basically for each <code>f</code> keyword you convert<br />the indices to positive numbers (translate the negative numbers to the correct positive index),<br />and then the set of the numbers is an <em>id</em> for that vertex. So you can store an <em>id to index<br />map</em> to help look up the indices.</p>

<pre><code>
const idToIndexMap = {}
const webglIndices = [];

function addVertex(vert) {
  const ptn = vert.split('/');
  // first convert all the indices to positive indices
  const indices = ptn.forEach((objIndexStr, i) => {
    if (!objIndexStr) {
      return;
    }
    const objIndex = parseInt(objIndexStr);
    return objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
  });
  // now see that particular combination of position,texcoord,normal
  // already exists
  const id = indices.join(',');
  let vertIndex = idToIndexMap[id];
  if (!vertIndex) {
    // No. Add it.
    vertIndex = webglVertexData[0].length / 3;
    idToIndexMap[id] = vertexIndex;
    indices.forEach((index, i) => {
      if (index !== undefined) {
        webglVertexData[i].push(...objVertexData[i][index]);
      }
    }
  }
  webglIndices.push(vertexIndex);
}
</code></pre>

<p>Or you could just manually re-index if you think it's important.</p>

<h3>The code doesn't handle position only or position + texcoord only.</h3>

<p>The code as written assumes normals exists. Like we did for<br /><a href="webgl-3d-geometry-lathe.html">the lathe example</a> we could generate normals<br />if they don't exist, taking into account smoothing groups if we want. Or we<br />could also use different shaders that either don't use normals or compute normals.</p>

<h3>You shouldn't use .OBJ files</h3>

<p>Honestly you should not use .OBJ files IMO. I mostly wrote this as an example.<br />If you can pull vertex data out of a file you can write importers for any format.</p>

<p>Problems with .OBJ files include</p>

<ul>
<li><p>no support for lights or cameras</p>

<p>That might be okay because maybe you're loading a bunch of parts<br />(like trees, bushes, rocks for a landscape) and you don't need cameras<br />or lights. Still it's nice to have the option if you want to load entire scenes<br />as some artist created them.</p></li>
<li><p>No hierarchy, No scene graph</p>

<p>If you want to load a car ideally you'd like to be able to turn the wheels<br />and have them spin around their centers. This is impossible with .OBJ<br />because .OBJ contains no <a href="webgl-scene-graph.html">scene graph</a>. Better formats<br />include that data which is much more useful if you want to be able to orient<br />parts, slide a window, open a door, move the legs of a character, etc...</p></li>
<li><p>no support for animation or skinning</p>

<p>We went over <a href="webgl-skinning.html">skinning</a> elsewhere but .OBJ provides no<br />data for skinning and no data for animation. Again that might be okay<br />for your needs but I'd prefer one format that handles more.</p></li>
<li><p>.OBJ doesn't support more modern materials.</p>

<p>Materials are usually pretty engine specific but lately there is at least<br />some agreement on physically based rendering materials. .OBJ doesn't support<br />that AFAIK.</p></li>
<li><p>.OBJ requires parsing</p>

<p>Unless you're making a generic viewer for users to upload .OBJ files into it<br />the best practice is to use a format that requires as little parsing as possible.<br />.GLTF is a format designed for WebGL. It uses JSON so you can just load it in.<br />For binary data it uses formats that are ready to load into the GPU directly,<br />no need to parse numbers into arrays most of the time.</p>

<p>You can see an example of loading a .GLTF file in <a href="webgl-skinning.html">the article on skinning</a>.</p>

<p>If you have .OBJ files you want to use the best practice would be to convert them<br />to some other format first, offline, and then use the better format on your page.</p></li>
</ul>